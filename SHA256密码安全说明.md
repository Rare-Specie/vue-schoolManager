# SHA256密码安全实现说明

## 概述
本项目已实现使用SHA256算法对用户密码进行哈希处理，确保密码在传输和存储过程中的安全性。

## 修改内容

### 1. 新增加密工具模块
**文件位置**: `src/utils/crypto.ts`

该模块提供以下功能：
- `hashPassword(password: string)`: 对密码进行SHA256哈希
- `verifyPassword(password: string, hashedPassword: string)`: 验证密码是否匹配
- `generateSalt()`: 生成随机盐值（用于后端增强安全性）
- `hashPasswordWithSalt(password: string, salt: string)`: 使用盐值进行哈希

### 2. 修改登录逻辑
**文件位置**: `src/stores/auth.ts`

在 `handleLogin` 函数中：
```typescript
// 对密码进行SHA256哈希
const hashedData = {
  ...data,
  password: hashPassword(data.password)
}
const response = await login(hashedData)
```

### 3. 修改修改密码逻辑
**文件位置**: `src/stores/auth.ts`

在 `handleChangePassword` 函数中：
```typescript
// 对原密码和新密码都进行SHA256哈希
const hashedData = {
  oldPassword: hashPassword(data.oldPassword),
  newPassword: hashPassword(data.newPassword)
}
await updatePassword(hashedData)
```

## 安全特性

### 前端安全
1. **密码哈希**: 所有密码在发送到后端前都会进行SHA256哈希
2. **不传输明文**: 原始密码永远不会离开前端
3. **一致性验证**: 修改密码时同时验证原密码和新密码的哈希值

### 后端配合建议
为了实现完整的安全方案，后端应该：

1. **存储哈希值**: 数据库中存储SHA256哈希后的密码，而非明文
2. **盐值增强**: 为每个用户生成唯一盐值，使用 `hashPasswordWithSalt(password, salt)` 
3. **防止彩虹表**: 使用盐值可以有效防止彩虹表攻击
4. **重哈希**: 在验证时可以重新哈希对比，或存储最终哈希值

### 示例后端验证逻辑
```javascript
// 用户注册/修改密码时
const salt = generateSalt();
const hashedPassword = hashPasswordWithSalt(password, salt);
// 存储 hashedPassword 和 salt 到数据库

// 用户登录时
const user = await findUser(username);
const inputHash = hashPasswordWithSalt(inputPassword, user.salt);
if (inputHash === user.password) {
  // 验证通过
}
```

## 使用说明

### 登录流程
1. 用户输入用户名、密码和角色
2. 前端对密码进行SHA256哈希
3. 发送哈希后的密码到后端
4. 后端验证哈希值并返回token

### 修改密码流程
1. 用户输入原密码、新密码和确认密码
2. 前端对原密码和新密码分别进行SHA256哈希
3. 发送哈希值到后端
4. 后端验证原密码哈希，更新新密码哈希

## 依赖说明
- `crypto-js`: 用于SHA256加密算法
- `@types/crypto-js`: TypeScript类型定义

## 注意事项
1. **HTTPS**: 建议在生产环境使用HTTPS，确保传输安全
2. **后端适配**: 后端需要相应修改以支持哈希密码验证
3. **密码强度**: 前端仍应保持密码强度验证（长度、复杂度等）
4. **兼容性**: 如果已有用户系统，需要考虑平滑迁移方案

## 测试建议
1. 测试正常登录流程
2. 测试修改密码功能
3. 验证错误密码提示
4. 检查网络请求中的密码是否为哈希值